const express = require('express');
const cors = require('cors');
const morgan = require('morgan');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const { v4: uuidv4 } = require('uuid');
const WebSocket = require('ws');
const http = require('http');
const path = require('path');
const crypto = require('crypto');

// Import des modules de base de donn√©es
const PolygonService = require('./services/PolygonService');
const MessageService = require('./services/MessageService');
const UserService = require('./services/UserService');

// Configuration
const PORT = process.env.PORT || 3000;
const API_KEY = process.env.API_KEY || 'parcelle-plus-secret-key-2024';
const RATE_LIMIT_REQUESTS = process.env.RATE_LIMIT_REQUESTS || 100;
const RATE_LIMIT_WINDOW = process.env.RATE_LIMIT_WINDOW || 15;

const app = express();

// ========== MIDDLEWARES DE S√âCURIT√â ==========

// Helmet pour s√©curiser les headers HTTP
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "https:"],
        },
    },
    crossOriginEmbedderPolicy: false
}));

// Rate limiting global
const globalLimiter = rateLimit({
    windowMs: RATE_LIMIT_WINDOW * 60 * 1000, // 15 minutes par d√©faut
    max: RATE_LIMIT_REQUESTS, // 100 requ√™tes par d√©faut
    message: {
        error: 'Trop de requ√™tes depuis cette IP',
        retryAfter: RATE_LIMIT_WINDOW * 60
    },
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res) => {
        console.log(`üö® Rate limit d√©pass√© pour IP: ${req.ip}`);
        res.status(429).json({
            error: 'Trop de requ√™tes depuis cette IP',
            retryAfter: RATE_LIMIT_WINDOW * 60
        });
    }
});

// Rate limiting sp√©cifique pour les API
const apiLimiter = rateLimit({
    windowMs: 1 * 60 * 1000, // 1 minute
    max: 30, // 30 requ√™tes par minute
    message: {
        error: 'Trop de requ√™tes API',
        retryAfter: 60
    }
});

// CORS restrictif pour IP publique
app.use(cors({
    origin: ['http://localhost:3000', 'http://37.66.21.17:3000'],
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-API-Key'],
    credentials: false
}));

// Logging des requ√™tes
app.use(morgan('combined'));

// Parse des donn√©es JSON
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended: true, limit: '1mb' }));

// Appliquer le rate limiting global
app.use(globalLimiter);

// ========== MIDDLEWARE D'AUTHENTIFICATION ==========

// Middleware pour v√©rifier la cl√© API
const authenticateAPI = (req, res, next) => {
    const apiKey = req.header('X-API-Key');
    const authHeader = req.header('Authorization');
    
    // V√©rifier la cl√© API dans le header X-API-Key
    if (apiKey === API_KEY) {
        req.authenticated = true;
        return next();
    }
    
    // V√©rifier la cl√© API dans Authorization Bearer
    if (authHeader && authHeader.startsWith('Bearer ')) {
        const token = authHeader.substring(7);
        if (token === API_KEY) {
            req.authenticated = true;
            return next();
        }
    }
    
    // Log de tentative d'acc√®s non autoris√©
    console.log(`üîí Tentative d'acc√®s non autoris√© depuis IP: ${req.ip}`);
    console.log(`üîí User-Agent: ${req.get('User-Agent')}`);
    
    return res.status(401).json({
        error: 'Authentification requise',
        message: 'Cl√© API manquante ou invalide'
    });
};

// Services
const polygonService = new PolygonService();
const messageService = new MessageService();
const userService = new UserService();

// Cr√©er le serveur HTTP
const server = http.createServer(app);

// Configuration WebSocket s√©curis√©e
const wss = new WebSocket.Server({ 
    server,
    verifyClient: (info) => {
        // V√©rifier l'origine des connexions WebSocket
        const origin = info.origin;
        const allowedOrigins = [
            'http://localhost:3000',
            'http://37.66.21.17:3000'
        ];
        
        if (allowedOrigins.includes(origin)) {
            return true;
        }
        
        console.log(`üîí Connexion WebSocket refus√©e depuis: ${origin}`);
        return false;
    }
});

// Gestion des connexions WebSocket
const clients = new Map();

wss.on('connection', (ws, req) => {
    const clientId = uuidv4();
    const clientInfo = {
        id: clientId,
        ws: ws,
        ip: req.socket.remoteAddress,
        userAgent: req.headers['user-agent'],
        connectedAt: new Date(),
        authenticated: false
    };
    
    clients.set(clientId, clientInfo);
    console.log(`üîå Client connect√©: ${clientId} (${clientInfo.ip})`);
    console.log(`üë• Clients connect√©s: ${clients.size}`);

    // Envoyer un message de bienvenue avec demande d'authentification
    ws.send(JSON.stringify({
        type: 'welcome',
        clientId: clientId,
        message: 'Connexion √©tablie - Authentification requise',
        requiresAuth: true
    }));

    ws.on('message', async (data) => {
        try {
            const message = JSON.parse(data);
            console.log(`üì® Message re√ßu de ${clientId}:`, message.type);
            
            switch (message.type) {
                case 'authenticate':
                    if (message.apiKey === API_KEY) {
                        clientInfo.authenticated = true;
                        ws.send(JSON.stringify({
                            type: 'auth_success',
                            message: 'Authentification r√©ussie'
                        }));
                        console.log(`üîì Client authentifi√©: ${clientId}`);
                    } else {
                        ws.send(JSON.stringify({
                            type: 'auth_failed',
                            message: 'Cl√© API invalide'
                        }));
                        console.log(`üîí √âchec authentification: ${clientId}`);
                    }
                    break;
                    
                case 'ping':
                    if (clientInfo.authenticated) {
                        ws.send(JSON.stringify({ type: 'pong' }));
                    }
                    break;
                    
                case 'join_room':
                    if (clientInfo.authenticated) {
                        clientInfo.room = message.room;
                        ws.send(JSON.stringify({
                            type: 'room_joined',
                            room: message.room
                        }));
                    }
                    break;
                    
                case 'send_message':
                    if (clientInfo.authenticated) {
                        await handleChatMessage(clientId, message);
                    } else {
                        ws.send(JSON.stringify({
                            type: 'error',
                            message: 'Authentification requise'
                        }));
                    }
                    break;
                    
                default:
                    ws.send(JSON.stringify({
                        type: 'error',
                        message: 'Type de message non support√©'
                    }));
            }
        } catch (error) {
            console.error('‚ùå Erreur WebSocket:', error);
            ws.send(JSON.stringify({
                type: 'error',
                message: 'Erreur traitement message'
            }));
        }
    });

    ws.on('close', () => {
        clients.delete(clientId);
        console.log(`üîå Client d√©connect√©: ${clientId}`);
        console.log(`üë• Clients connect√©s: ${clients.size}`);
    });
});

// Function pour g√©rer les messages de chat
async function handleChatMessage(clientId, message) {
    try {
        const savedMessage = await messageService.saveMessage({
            senderId: message.senderId,
            senderName: message.senderName,
            content: message.content,
            room: message.room || 'general'
        });
        
        // Diffuser le message √† tous les clients authentifi√©s de la room
        const broadcastMessage = {
            type: 'new_message',
            message: savedMessage
        };
        
        clients.forEach((client, id) => {
            if (client.authenticated && 
                (client.room === message.room || !message.room)) {
                if (client.ws.readyState === WebSocket.OPEN) {
                    client.ws.send(JSON.stringify(broadcastMessage));
                }
            }
        });
        
    } catch (error) {
        console.error('‚ùå Erreur sauvegarde message:', error);
    }
}

// Function pour diffuser des notifications
function broadcastNotification(notification) {
    const message = JSON.stringify({
        type: 'notification',
        ...notification
    });
    
    clients.forEach((client) => {
        if (client.authenticated && client.ws.readyState === WebSocket.OPEN) {
            client.ws.send(message);
        }
    });
}

// ========== ROUTES API S√âCURIS√âES ==========

// Route de sant√© publique (sans authentification)
app.get('/api/health', (req, res) => {
    res.json({
        status: 'OK',
        timestamp: new Date().toISOString(),
        version: '1.0.0-secure',
                    ip: '37.66.21.17',
        port: PORT,
        security: {
            authenticated: false,
            rateLimit: true,
            corsEnabled: true
        }
    });
});

// Appliquer l'authentification et le rate limiting pour toutes les autres routes API
app.use('/api', apiLimiter);
app.use('/api', authenticateAPI);

// Route d'information (authentifi√©e)
app.get('/api/info', (req, res) => {
    res.json({
        message: 'ParcellePlus Server API - Version S√©curis√©e',
        version: '1.0.0-secure',
        timestamp: new Date().toISOString(),
        endpoints: {
            polygons: '/api/polygons',
            messages: '/api/messages',
            users: '/api/users',
            websocket: 'ws://37.66.21.17:3000'
        },
        security: {
            authenticated: true,
            rateLimit: true,
            corsEnabled: true
        }
    });
});

// Routes pour les polygones (authentifi√©es)
app.get('/api/polygons', async (req, res) => {
    try {
        const { userId, limit = 100 } = req.query;
        const polygons = await polygonService.getAllPolygons(userId, limit);
        res.json(polygons);
    } catch (error) {
        console.error('‚ùå Erreur r√©cup√©ration polygones:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

app.get('/api/polygons/:id', async (req, res) => {
    try {
        const polygon = await polygonService.getPolygonById(req.params.id);
        if (!polygon) {
            return res.status(404).json({ error: 'Polygone non trouv√©' });
        }
        res.json(polygon);
    } catch (error) {
        console.error('‚ùå Erreur r√©cup√©ration polygone:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

app.post('/api/polygons', async (req, res) => {
    try {
        const polygonData = req.body;
        const savedPolygon = await polygonService.savePolygon(polygonData);
        
        // Notifier les autres clients authentifi√©s
        broadcastNotification({
            type: 'polygon_created',
            polygon: savedPolygon
        });
        
        res.status(201).json(savedPolygon);
    } catch (error) {
        console.error('‚ùå Erreur sauvegarde polygone:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

app.put('/api/polygons/:id', async (req, res) => {
    try {
        const updatedPolygon = await polygonService.updatePolygon(req.params.id, req.body);
        if (!updatedPolygon) {
            return res.status(404).json({ error: 'Polygone non trouv√©' });
        }
        
        // Notifier les autres clients authentifi√©s
        broadcastNotification({
            type: 'polygon_updated',
            polygon: updatedPolygon
        });
        
        res.json(updatedPolygon);
    } catch (error) {
        console.error('‚ùå Erreur mise √† jour polygone:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

app.delete('/api/polygons/:id', async (req, res) => {
    try {
        const deleted = await polygonService.deletePolygon(req.params.id);
        if (!deleted) {
            return res.status(404).json({ error: 'Polygone non trouv√©' });
        }
        
        // Notifier les autres clients authentifi√©s
        broadcastNotification({
            type: 'polygon_deleted',
            polygonId: req.params.id
        });
        
        res.json({ message: 'Polygone supprim√©' });
    } catch (error) {
        console.error('‚ùå Erreur suppression polygone:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Routes pour les messages (authentifi√©es)
app.get('/api/messages', async (req, res) => {
    try {
        const { room = 'general', limit = 50 } = req.query;
        const messages = await messageService.getMessages(room, limit);
        res.json(messages);
    } catch (error) {
        console.error('‚ùå Erreur r√©cup√©ration messages:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

app.post('/api/messages', async (req, res) => {
    try {
        const messageData = req.body;
        const savedMessage = await messageService.saveMessage(messageData);
        
        // Diffuser le message via WebSocket
        broadcastNotification({
            type: 'new_message',
            message: savedMessage
        });
        
        res.status(201).json(savedMessage);
    } catch (error) {
        console.error('‚ùå Erreur sauvegarde message:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Routes pour les utilisateurs (authentifi√©es)
app.get('/api/users/online', (req, res) => {
    const onlineUsers = Array.from(clients.values())
        .filter(client => client.authenticated)
        .map(client => ({
            id: client.id,
            ip: client.ip,
            connectedAt: client.connectedAt,
            room: client.room
        }));
    
    res.json({
        count: onlineUsers.length,
        users: onlineUsers
    });
});

// Route pour les statistiques (authentifi√©e)
app.get('/api/stats', async (req, res) => {
    try {
        const polygonStats = await polygonService.getStats();
        const messageStats = await messageService.getMessageStats();
        
        res.json({
            polygons: polygonStats,
            messages: messageStats,
            websocket: {
                totalConnections: clients.size,
                authenticatedConnections: Array.from(clients.values()).filter(c => c.authenticated).length
            }
        });
    } catch (error) {
        console.error('‚ùå Erreur r√©cup√©ration statistiques:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Gestion des erreurs 404
app.use((req, res) => {
    res.status(404).json({
        error: 'Endpoint non trouv√©',
        message: 'Cette route n\'existe pas'
    });
});

// Gestion des erreurs globales
app.use((err, req, res, next) => {
    console.error('‚ùå Erreur serveur:', err);
    res.status(500).json({
        error: 'Erreur serveur interne',
        message: 'Une erreur inattendue s\'est produite'
    });
});

// D√©marrer le serveur
server.listen(PORT, '0.0.0.0', () => {
    console.log('üöÄ ========================================');
    console.log(`üöÄ Serveur ParcellePlus S√âCURIS√â d√©marr√© sur le port ${PORT}`);
    console.log(`üöÄ URL publique: http://37.66.21.17:${PORT}`);
    console.log(`üöÄ WebSocket: ws://37.66.21.17:${PORT}`);
    console.log(`üîí Authentification: API Key requise`);
    console.log(`üõ°Ô∏è  Rate limiting: ${RATE_LIMIT_REQUESTS} req/${RATE_LIMIT_WINDOW}min`);
    console.log('üöÄ ========================================');
});

// Gestion de l'arr√™t propre du serveur
process.on('SIGINT', () => {
    console.log('\nüõë Arr√™t du serveur...');
    server.close(() => {
        console.log('‚úÖ Serveur arr√™t√©');
        process.exit(0);
    });
});

process.on('SIGTERM', () => {
    console.log('\nüõë Arr√™t du serveur (SIGTERM)...');
    server.close(() => {
        console.log('‚úÖ Serveur arr√™t√©');
        process.exit(0);
    });
}); 